<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        深入剖析HashMap - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/">
        </div>
        <div class="name">
            <i>Li Liu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-为什么需要HashMap？用处？"><span class="toc-text">1 为什么需要HashMap？用处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HashMap的底层实现"><span class="toc-text">2 HashMap的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-构造一个HashMap发生了什么"><span class="toc-text">3 构造一个HashMap发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-无参的HashMap"><span class="toc-text">3.1 无参的HashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-指定初始容量"><span class="toc-text">3.2 指定初始容量</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HashMap的put"><span class="toc-text">4 HashMap的put</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-hash算法扰动函数"><span class="toc-text">4.1 hash算法扰动函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-核心逻辑"><span class="toc-text">4.2 核心逻辑</span></a></li></ol></li>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        深入剖析HashMap
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-03-28 17:01:42</span></span>
        
        
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h2 id="1-为什么需要HashMap？用处？"><a href="#1-为什么需要HashMap？用处？" class="headerlink" title="1 为什么需要HashMap？用处？"></a>1 为什么需要HashMap？用处？</h2><p>首先，Map是一个映射键和值的对象，类似于字典(Python中就有字典的概念)。</p>
<p>如果不考虑Map，我们常用的储存元素的容器大多是数组和链表。数组储存元素的好处在于根据下标查找元素迅速，因为不需要遍历元素，但其增加或删除元素却需要移动大量元素，因此数组在增删上性能不好(ArrayList也是一样的道理，本质也是数组)。而链表由于底层数据结构采用Node节点相连接，因此增删元素往往只涉及元素自身及其前后节点的操作，非常方便和快速，但其查找元素时需要遍历链表直到找到指定的元素为止，因此在需要大量的查找操作时链表性能往往不佳。</p>
<p>那么能不能有一种数据结构，能够满足查找和增删元素都非常快速？这个时候就出现了哈希表这种数据结构，相对而言，哈希表查询没数组快，插入没链表快，但却综合了两者的优点，在各个方面性能都能表现得比较好。</p>
<p>而HashMap就是一个哈希表的实现，在JDK1.8中，HashMap底层采用了<strong>数组+链表+红黑树</strong>实现，能够实现快速的查找和插入。HashMap能够根据键值快速的查找到相应的值，也能够根据要插入的值快速的定位插入，类似于前面说的字典的概念。</p>
<h2 id="2-HashMap的底层实现"><a href="#2-HashMap的底层实现" class="headerlink" title="2 HashMap的底层实现"></a>2 HashMap的底层实现</h2><p>HashMap底层采用<strong>数组+链表+红黑树</strong>实现，当往HashMap中插入键值对时，会根据key值的hashcode经过处理之后找到在<strong>哈希桶</strong>(即HashMap底层的数组)中对应的桶位置，将键值对(封装为<strong>Node</strong>元素)保存在桶中，若之后新添加的元素计算得出的位置已保存有元素时，则以<strong>单向链表</strong>的形式将新Node挂载到链表尾部，当链表中的元素个数超过阈值时单向链表会转换为<strong>红黑树</strong>。而查找元素时也是根据key值的hashcode找到对应的桶位置，再将key值与桶中链表或红黑树中的元素比较找出相等的key值，就找到了要查找的键值对，这样根据key值查找value值不需要遍历桶中所有的元素，根据key值的hashcode直接定位到对应的桶位置，再遍历桶中的链表比较即可找到要查找的元素。这样键值对的插入与查找性能都比较好。</p>
<p>HashMap示意图(未涉及红黑树时):</p>
<p><img src="/images/watermark/collection/HashMap.png" alt></p>
<p>首先，看一下HashMap封装的数据结构：</p>
<ul>
<li>Hash桶</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap中的节点数组，即Hash桶，用于存放元素链表或红黑树</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>Hash桶是HashMap中用于存放元素链表或红黑树的数组，看一下Node节点的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    	<span class="comment">//处理后的hash码，可以标识key的位置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    	<span class="comment">//key值</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">    	<span class="comment">//value值</span></span><br><span class="line">        V value;</span><br><span class="line">    	<span class="comment">//下一节点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Node是一个单向链表的节点，当往HashMap中存放元素时，实际是往数组中保存Node对象，当一个桶中保存多个Node时，其实保存的是一个单向链表(桶中Node数量超过8时链表会转换为红黑树)。</p>
<p>下面再看一下HashMap中定义的一些变量或常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量，16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认装载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//阈值，当桶节点数量大于等于8时桶中保存的链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//阈值，当桶节点数量变为小于等于6时桶中保存的红黑树转换为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//当需要将桶中链表转换为红黑树时整个HashMap的最小容量值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//已保存的key-value键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//已保存的key-value达到此阈值时需要调整容量大小(=capacity * load factor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//哈希表的装载因子，计算threshold</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>可以看出：</p>
<ul>
<li>整体上，HashMap定义了其默认容量、最大容量，以及需要调整容量时的阈值。</li>
<li>单个桶来说，定义了key-value的Node&lt;K,V&gt;的链表的阈值TREEIFY_THRESHOLD，超过此阈值时相应桶中的链表就需要转换为红黑树，以适应快速查找的要求；同时，当删除key-value时，桶中Node&lt;K,V&gt;数量减少,若桶中节点数量由8(TREEIFY_THRESHOLD)减少为6(UNTREEIFY_THRESHOLD)，则红黑树需要再转换为单向链表。</li>
</ul>
<p>有2个重要的特性影响着HashMap的性能，分别是capacity(容量)和load factor(加载因子)。</p>
<p>其中capacity表示哈希表bucket的数量，HashMap的默认值是16。load factor加载因子表示当一个map填满了达到这个比例之后的bucket时候，和ArrayList一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程也叫做重哈希。默认的load factor为0.75 。</p>
<p>这样，HashMap就利用<strong>数组+单向链表+红黑树</strong>实现了key-value的快速增删查改。至于实现的细节，接下来分为几个部分分开阐述。</p>
<h2 id="3-构造一个HashMap发生了什么"><a href="#3-构造一个HashMap发生了什么" class="headerlink" title="3 构造一个HashMap发生了什么"></a>3 构造一个HashMap发生了什么</h2><p>前面介绍了HashMap的底层数据结构以及一些变量和常量的意义，那么当我们使用HashMap时，其底层细节究竟是怎么实现的？</p>
<h4 id="3-1-无参的HashMap"><a href="#3-1-无参的HashMap" class="headerlink" title="3.1 无参的HashMap"></a>3.1 无参的HashMap</h4><p>先从无参构造(不指定容量),创建一个HashMap对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>new一个HashMap是简单的，看一下源码的调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>只是指定了装载因子为默认的装载因子(0.75f)，加上之前的介绍，可以知道我们会得到一个初始容量为16，装载因子为0.75的HashMap。</p>
<h3 id="3-2-指定初始容量"><a href="#3-2-指定初始容量" class="headerlink" title="3.2 指定初始容量"></a>3.2 指定初始容量</h3><p>创建一个HashMap对象，指定初始容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>跟踪源码调用过程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//装载因子为默认装载因子(0.75f)</span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用了有参构造函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">    	<span class="comment">//初始化装载因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    	<span class="comment">//指定阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出HashMap的阈值调用了内部方法tableSizeFor(int cap)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法最终使得 阈值 = 大于或等于指定容量的最小的2的整数次方，例如：</p>
<ul>
<li>指定初始容量为3，则初始化阈值为4</li>
<li>指定初始容量为5，则初始化阈值为8</li>
<li>……</li>
</ul>
<p>以5举例,=0101：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n = 5-1 = 4;</span><br><span class="line">n = n | (n&gt;&gt;&gt;1) = 0101 | 0010 = 0111 = 7</span><br><span class="line">n = n | (n&gt;&gt;&gt;2) = 0111 | 0001 = 0111 = 7</span><br><span class="line">n = n | (n&gt;&gt;&gt;4) = 0111 | 0000 = 0111 = 7</span><br><span class="line">n = n | (n&gt;&gt;&gt;8) = 00000111 | 00000000 = 7</span><br><span class="line">n = n | (n&gt;&gt;&gt;16) = 00000111 | 00000000 = 7</span><br><span class="line">return n+1(8);</span><br></pre></td></tr></table></figure>
<p>返回后，HashMap的构造方法就完成了,一共做了两件事：</p>
<ul>
<li>指定装载因子为默认装载因子(0.75)</li>
<li>初始化阈值 = 大于或等于指定容量的最小的2的整数次方(或者MAXIMUM_CAPACITY)或1)</li>
</ul>
<p>无论无参构造方法还是指定初始容量，可以看出来，<strong>只是初始化了阈值threshold及装载因子loadFactor，并没有初始化底层节点数组 Node&lt;K,V&gt;[] table</strong>。</p>
<h2 id="4-HashMap的put"><a href="#4-HashMap的put" class="headerlink" title="4 HashMap的put"></a>4 HashMap的put</h2><p>前面看到了HashMap底层采用<strong>数组+单向链表+红黑树(还没讨论)</strong>，而创建一个HashMap对象时，也只会初始化其装载因子和阈值，下面看一下当使用HashMap的put(K,V)方法时经历了哪些过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-hash算法扰动函数"><a href="#4-1-hash算法扰动函数" class="headerlink" title="4.1 hash算法扰动函数"></a>4.1 hash算法扰动函数</h3><p>调用put(K,V)方法时，内部调用了put(int hash, K key, V value,  boolean onlyIfAbsent, boolean evict)，然而调用这个方法之前可以看出第一个参数也调用了内部方法计算hash值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    	<span class="comment">// 使用hashCode的值和hashCode的值无符号右移16位做异或操作</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，对象的hashCode值是根据我们自定义的hashcode()方法生成的32位整型数字，而从上面的方法可以看出来，HashMap中Node中的hash值 =  (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，即利用了key的hashcode的低16位与高16位做异或运算，那么为什么需要这么做呢？</p>
<p>我们知道，HashMap存放数据的时候需要利用key的hash值与（哈希桶容量-1）做与(&amp;)运算，进而算出数据需要储存在哈希桶的什么位置。(后面会提到，先看其中一点源码)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>而哈希桶容量刚开始是比较小的，随着其动态扩容也不可能达到hash值的最大值，虽然其理论最大容量为2的30次方，但限于内存的原因远远达不到这个值。因此若直接用HashMap的capacity与key的hashCode值做与运算那么实际利用的只是较低的几位(由capacity限制的)。这样一来，虽然不同的key值的hasCode值相同的几率很小，但求与运算之后的结果相同的概率会比想象中要大，发生hash碰撞的几率也会变大。因此，要想办法将key的hashCode值的高位影响向底位扩展，因此就用到了这个方法，下面看一下实际的效果：</p>
<p><img src="/images/collection/hash异或.png" alt></p>
<p>这个方法也即是扰动函数，目的就是为了使得真正利用的hash值更加不确定来降低hash碰撞的几率。</p>
<h3 id="4-2-核心逻辑"><a href="#4-2-核心逻辑" class="headerlink" title="4.2 核心逻辑"></a>4.2 核心逻辑</h3><p>下面就进入到了真正的put方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//tab存放当前的哈希桶，p用作临时链表节点</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">//如果当前哈希表是空的，执行初始化操作</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化哈希表(resize()方法综合了初始化和扩容)</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">//如果当前index的节点是空的，表示没有发生哈希碰撞。直接构建一个新节点Node，挂载在index处即可</span></span><br><span class="line">    	<span class="comment">//这里利用的是哈希值 &amp; 哈希桶的长度-1，替代模运算</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则 发生了哈希冲突。</span></span><br><span class="line">            <span class="comment">//e临时节点</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//如果哈希值相等，key也相等，将现有节点引用赋给临时节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">///将当前节点引用赋值给e</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//当现有节点是红黑树节点时</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当哈希冲突的节点是链表节点，但与链表头部节点不相等，那么需要遍历链表决定是覆盖还是添加</span></span><br><span class="line">                <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//遍历到尾部，追加新节点到尾部</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果追加节点后，链表数量》=8，则转化为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果找到了要覆盖的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//遍历节点后移</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果e不是null，说明有需要覆盖的节点</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//覆盖节点值，并返回原oldValue</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果执行到了这里，说明插入了一个新的节点，所以会修改modCount,并返回null</span></span><br><span class="line">    	<span class="comment">//修改modCount，即修改次数加1</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//更新size，并判断是否需要扩容(size&gt;阈值)</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">    	<span class="comment">//这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看得出来，当往HashMap里增添元素时，底层会根据传入的key值决定是插入新节点还是修改老节点，并且也涉及到了之前提到的<strong>数组+单向链表+红黑树</strong>，对每种情况都做了对应的处理。其中，当哈希表是空的以及需要扩容时都调用到了扩容方法：resize()。这是一个很重要的方法，下面看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    	<span class="comment">//oldTab 为当前表的哈希桶</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    	<span class="comment">//当前哈希桶的容量 length</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    	<span class="comment">//当前的阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    	<span class="comment">//初始化新的容量和阈值为0</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//当前哈希桶的容量大于0，说明是扩容不是初始化</span></span><br><span class="line">            <span class="comment">//如果当前容量已经到达上限</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//则设置阈值是2的31次方-1</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//同时返回当前的哈希桶，不再扩容</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;<span class="comment">//否则新的容量为旧的容量的两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//如果旧的容量大于等于默认初始容量16</span></span><br><span class="line">                <span class="comment">//那么新的阈值也等于旧的阈值的两倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;<span class="comment">//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况,此时是初始化哈希桶</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//那么新表的容量就等于旧的阈值</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">//如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况</span></span><br><span class="line">            <span class="comment">//此时新表的容量为默认的容量 16</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">//新的阈值为默认容量16 * 默认加载因子0.75f = 12</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span></span><br><span class="line">            <span class="comment">//根据新表容量 和 加载因子 求出新的阈值</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//进行越界修复</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//更新阈值 </span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    		<span class="comment">//根据新的容量 构建新的哈希桶</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    	<span class="comment">//更新哈希桶引用</span></span><br><span class="line">        table = newTab;</span><br><span class="line">    	<span class="comment">//如果以前的哈希桶中有元素</span></span><br><span class="line">        <span class="comment">//下面开始将当前哈希桶中的所有节点转移到新的哈希桶中</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历老的哈希桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                <span class="comment">//临时节点e</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//如果当前桶中有元素,则将链表赋值给e</span></span><br><span class="line">                    <span class="comment">//将原哈希桶置空以便GC</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果当前链表中就一个元素</span></span><br><span class="line">                        <span class="comment">//直接将这个元素放置在新的哈希桶里。</span></span><br><span class="line">                        <span class="comment">//注意这里取下标是用 哈希值 与 桶的长度-1</span></span><br><span class="line">                        <span class="comment">//由于桶的长度是2的n次方，这么做其实是等于一个模运算。但是效率更高</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//如果发生过哈希碰撞 ,而且是节点数超过8个，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order //如果当前链表不止一个元素</span></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        因为扩容是容量翻倍，所以原链表上的每个节点,现在可能存放在原来的下标</span></span><br><span class="line"><span class="comment">                        即low位，或者扩容后的下标，即high位。high位 = low位+原哈希桶容量</span></span><br><span class="line"><span class="comment">                        低位链表的头结点、尾节点</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位链表的头节点、尾节点</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;<span class="comment">//临时节点 存放e的下一个节点</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            因为老哈希桶容量与hash与运算取决于哈希桶容量(较小)，所以扩容后需要重新计							   算数据存放的位置</span></span><br><span class="line"><span class="comment">                            利用哈希值与旧的容量，可以得到哈希值取模后是大于等于oldCap还是</span></span><br><span class="line"><span class="comment">                            小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//给头尾节点引用赋值</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//高位也是相同的逻辑</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//循环直到链表结束</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//将低位链表存放在原index处</span></span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;<span class="comment">//将高位链表存放在新index处</span></span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回新的哈希桶(已按完成初始化或者扩容数据迁移)</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面一张图展示了HashMap的put(K key, V value)的核心逻辑，图片参考网络(自己总结后修改重新作图):</p>
<p><img src="/images/watermark/collection/HashMap-put.png" alt></p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
