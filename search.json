[{"title":"谈谈消息中间件","url":"/2018/12/23/谈谈消息中间件/","content":"## 1.使用消息队列的理由(使用场景,优点，缺点)\n\n### 1.1.使用场景与优点\n\n- 解耦\n&emsp;&emsp; 系统之间通信采用消息中间件，避免了直接使用接口调用，各个模块之间的功能调用借助于消息中间件进行通讯，模块之间的功能调用可以很方便的绑定与解除，业务及系统服务的耦合度降低，易于系统调整与扩展。\n\n- 异步\n&emsp;&emsp在许多场景下，用户请求的模块(或其他)的功能实现的同时要完成其他几个模块的功能调用，但用户请求的所要求的返回结果并不依赖于其他几个模块的返回结果，往往这时候被调用的模块任务执行往往是耗时的，多个模块顺序调用的情况下时间累加将会比较耗时，给用户的使用体验会很不友好。这种情况下，用户请求的模块完成自身业务后向其他模块发送消息，快速返回结果，其他模块异步执行，用户体验良好。\n\n- 削峰\n&emsp;&emsp系统访问高峰时，每秒并发数量剧增，系统处理能力不足(请求是并发的，若每个请求对应的业务也并发执行，如耗时操作，并发访问数据库等，系统无法承受)，这时若采用消息队列，则可以在收到大量的并发请求后发送消息到消息队列，而消息消费者(其他功能模块)按固定的可以承受的压力消费队列消息，在消费消息后完成业务处理。这样一来，就可以将系统访问高峰时的压力通过消息队列分摊到其他时间段，及削减了峰值压力，也提高了闲时系统利用率。\n\n### 1.2.缺点\n\n- 系统可用性降低\n&emsp;&emsp系统引入的外部依赖越多，越容易挂掉，本来只需调用接口即可，只要各个模块及dubbo通信不出问题即可，现在要同时保证消息中间件不出问题。\n\n- 系统复杂性提高\n\n&emsp;&emsp;引入MQ，意味着必须处理消息生产者、‘消息中间件、消息消费者任意一端可能引起的消息丢失，消息重复发送，大量消息积压，如何保证消息的顺序发送等各种复杂问题。\n\n## 2.消息中间件如何选型\n\n|          特性           |                           ActiveMQ                           |                           RabbitMQ                           |                      RocketMQ                       |                            Kafka                             |\n| :---------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------------: |\n|       单机吞吐量        |              万级，比Rocket和Kafka低一个数量级               |              万级，比Rocket和Kafka低一个数量级               |                       10万级                        | 10万级，这是Kafka最大的优点。一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |\n| topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百、几千的级别，吞吐量会有小幅度下降 |        topic从几十个到几百个的时候，吞吐量会大量下降         |\n|         时效性          |                             ms级                             |           微秒级，这是rabbirmq的一大特点，延迟最低           |                        ms级                         |                            ms级别                            |\n|         可用性          |                 高，基于主从架构实现高可用性                 |                 高，基于主从架构实现高可用性                 |                 非常高，分布式架构                  | 非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |\n|       消息可靠性        |                     有较低的概率丢失数据                     |                         基本不会丢失                         |           经过参数优化配置，可以做到0丢失           |               经过参数优化配置，可以做到0丢失                |\n|        核心特点         |                     MQ领域的功能及其完备                     |    基于erlang开发，所以并发能力很强，性能及其好，延时很低    |      MQ功能较为完善，还是分布是式的，扩展性好       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是实时的标准 |\n|       优劣势总结        | 非常成熟，功能强大，在业内大量的公司以及项目中都有应用。<br />偶尔会有低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区对其维护越来越少，而且主要是基于解耦合异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能及其好；而且开源提供的管理界面非常棒，用起来非常好用，在国内一些互联网近几年用rabbitmq也比较多。<br />但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，... |                         ...                         |                             ...                              |\n\n综上所述，经过对比：\n\n​    一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在大家用的都不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，不太推荐。\n\n​    后来大家都去用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司来说，几乎处于不可控的状态，但是确实是开源的，比较稳定的支持，活跃度也较高。\n\n​    ......\n\n## 3.如何保证消息队列的高可用\n\n#### （1）RabbitMQ的高可用\n\n​    RabbitMQ基于主从做高可用的\n\n ##### 单机模式\n\n  ​    demo使用，生产环境不会使用。\n\n##### 普通集群模式\n\n  ​    就是在多台机器上启动多个rabbitmq实例，每个机器启动一个。但是所创建的queue，只会放在一个rabbitmq实例上，但是每个实例都同步queue的元数据，消费者消费消息时，如果连接的是另外一个实例，那么这个实例会从queue所在的实例上拉取数据过来。\n\n  ​    这种方式其实也并不好，没有分布式，就是个普通集群因为这会导致消费者只能选择每次随机连接一个实例然后拉取数据，或者固定连接queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。\n\n  ​    而且如果放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果开启了消息持久化，让rabbit落地储存消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以从这个queue拉取数据。\n\n  ​    所以普通集群模式并没有高可用，这种方案主要是提高吞吐量。\n\n##### 镜像集群模式\n\n  ​    这种模式，才是rabbitmq的高可用方案，与普通集群模式不同，生产者所创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上。每次写消息到queue的时候,rabbitmq都会把queue的消息自动同步到多个实例。\n\n  ​    镜像集群的好处是真正的高可用，任何一个机器宕机了，其他机器都可以使用。坏处在于：性能开销很大，消息同步到所有机器，导致网络带宽压力和消耗很重；另外。这样的话拓展性差，如果某个queue负载很重，加机器的话那么新增的机器也包含了这个queue的所有数据，并没有办法线性扩展queue。\n\n  ​    镜像集群的开启：rabbitmq有很好的管理控制台，可以在后台新增一个策略，这个策略就是集群模式的策略，指定的时候可以要求数据同步到所有节点，也可以要求同步到指定的节点。然后再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上。\n\n  #### （2）Kafka的高可用\n\n  ​    分布式加主从复制......\n\n## 4.如何保证消息不被重复消费？(如何保证消费消费的幂等性)\n\n#### （1）消息重复发送的场景\n\n- 消费者已经处理完数据，但还没来得及确认，服务器宕机，rabbitmq(其他类似)没有收到确认会认为消息没有被消费，会重复发送消息给消费者\n\n#### （2）如何保证幂等性\n\n​    结合具体场景，比如：\n\n        - 如果消费者模块要执行数据库写，可以根据主键查一下，如果数据有了，就别插入了，update即可\n        - 如果是写redis，那没问题，因为每次都指定set操作，覆盖而已不会有问题，redis天然幂等性\n        - 不是以上场景，稍微复杂的情况下可以让生产者发送每条数据的时候，里面加一个全局的id类似订单id之类的东西，然后消费者消费消息的时候，先根据这个id去redis里面查一下(之前消费的消息数据保存在redis中)，如果没有消费过，就处理，然后将这个id写到redis。如果消费过了，就不再处理，保证别重复处理相同的消息即可。\n        - 还有基于数据库的唯一键来保证重复数据不会重复插入多条。\n\n​    总之保证MQ的幂等性要结合具体业务来看。\n\n## 5.如何保证消息的可靠性传输（如何处理消息丢失的问题）\n\n","categories":["架构","消息中间件"]},{"title":"JVM常见问题","url":"/2018/12/16/JVM常见问题/","content":"### 1. JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Root？\n\n- 什么是垃圾？\n\n  简单说就是内存中已经不再被使用的空间就是垃圾。\n\n- 要进行垃圾回收，如何判断一个对象可以被回收？\n\n  - 引用计数法（无法解决循环引用，已经不再使用）\n\n  - 枚举根节点做可达性分析（根搜索路径）\n\n    ![](/images/jvm/GC roots.png)\n\n    所谓的\"GC roots\"或者说traceing GC的“根集合”就是**一组必须活跃的引用**。\n\n    **基本思路就是通过一系列名为“GC Roots”的对象作为起始点，**从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根处出发，通过引用关系遍历对象树，能被遍历到的（可达的）对象就被判定为存活；没有遍历到的就自然被判定为死亡。\n\n- Java中可以作为GC Roots的对象\n\n  - 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象；\n  - 方法区中的类静态属性引用的对象；\n  - 方法区中常量引用的对象；\n  - 本地方法栈中JNI(Native)引用的对象；\n\n### 2. 如何盘点查看JVM系统默认值？\n\n#### 2.1 JVM的参数类型\n\n1. 标配参数(了解)\n   - -vsersion\n   - -help\n   - java -showversion\n2. x参数(了解)\n   - -Xint  解释执行\n   - Xcomp 第一次使用就编译成本地代码\n   - -Xmixed 混合模式\n3. **xx参数**\n\n- Boolean类型\n\n  -XX:+或者-某个属性值\n\n  +表示开启\n\n  -表示关闭\n\n  Case:\n\n  - 是否打印GC手机细节：-XX:-/+PrintGCDetails\n  - 是否使用串行垃圾收集器：-XX:-/+UseSerialGC\n\n- KV设值类型\n\n  公式：-XX:属性key=属性value\n\n  Case:\n\n  - -XX:MetaspaceSize=128m\n  - -XX:MaxTenuringThreshold=15\n\n4. jinfo举例，如何查看当前运行程序的配置(第一种查看方法)\n\n   - jinfo -flag 具体参数 java进程号\n   - jinfo -flags java进程号\n\n5. 例外（坑）\n\n   两个经典参数-Xms和-Xmx，如何解释？\n\n   - -Xms 等价于：-XX:InitialHeapSize\n   - -Xmx 等价于：-XX:MaxHeapSize\n\n#### 2.2 查看JVM参数(第二种)\n\n- java -XX:+PrintFlagsInitial [-version]\t(查看初始默认值)\n\n- java -XX:+PrintFlagsFinal [-version]     (主要查看修改更新)\n\n  = 为为修改过的\n\n  :=为修改过的\n\n- java -XX:+PrintCommandLineFlags [-version]\n\n#### 3 工作中常用参数\n\n- -Xms 初始大小内存，默认为物理内存1/64\n\n  等价于\t-XX:InitialHeapSize\n\n- -Xmx 最大分配内存，默认为物理内存1/4(内存大于192M时，否则为一半)\n\n  等价于\t-XX:MaxHeapSize\n\n- -Xss 设置单个线程栈的大小，一般默认是512k~1024k\n\n  等价于\t-XX:ThreadStackSize\n\n- -Xmn 设置年轻代大小，一般不调\n\n- -XX:MetaspaceSize\n\n  设置元空间大小：元空间的本质和永生代类似，都是对JVM规范中方法区的实现。不过元空间与永生代最大的区别在于：**元空间并不在虚拟机中，二货思使用本地内存 **。因此，默认情况下，元空间的大小仅受本地内存限制(但默认值不到21M,所以有时候要调整元空间的大小)。\n\n  典型： -Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags \n\n  -XX:+PrintGCDetails -XX:+UseSerialGC\t(常用参数，值不一定是这个)\n\n- -XX:+PrintGCDetails\n\n  - 输出详细GC收集日志信息\n\n    [GC (Allocation Failure) [PSYoungGen: 1848K->488K(2560K)] 1848K->732K(9728K), 0.0013387 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n\n    [Full GC (Allocation Failure) [PSYoungGen: 472K->0K(2560K)] [ParOldGen: 244K->621K(7168K)] 716K->621K(9728K), [Metaspace: 3425K->3425K(1056768K)], 0.0054785 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n\n  - GC\n\n    举例：\n\n    ![](/images/jvm/GC垃圾回收参数解读.png)\n\n    [GC [PSYoungGen: 334480k->4736K(334848K)] 597914->270331(1017536K), 0.0209890 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]\n\n  - FullGC\n\n    Full GC (Full GC大部分发生在老年代)：\n\n    [Full GC (Allocation Failure) [PSYoungGen: 472K->0K(2560K)] [ParOldGen: 244K->621K(7168K)] 716K->621K(9728K), [Metaspace: 3425K->3425K(1056768K)], 0.0054785 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n\n    举例：\n\n    ![](/images/jvm/Full GC垃圾回收参数解读.png)\n\n    [Full GC (System) [PSYoungGen: 3408K->0K(298688K)] [ParOldGen: 0K->3363K(682688K)] 3408K->3363K(991376K), [Metaspace: 10638K->10638K(131072K)], 0.0372600 secs] [Times: user=0.03 sys=0.00, real=0.04 secs]\n\n- -XX:SurvivorRatio  设置新生代中eden和S0/S1的比例\n\n  默认：-XX:SurvivorRatio=8，即 Eden:S0:S1 = 8:1:1\n\n  假如：-XX:SurvivorRatio=4，即 Eden:S0:S1 = 4:1:1\n\n  SurvivorRatio值就是设置Eden区在新生代的比例占多少，S0/S1相同\n\n- -XX:NewRatio \n\n  配置年轻代与老年代在堆空间的占比；\n\n  默认：\n\n  ​\t\t-XX:NewRatio=2,新生代占1，老年代2，年轻代占整个堆的1/3;\n\n  假如：\n\n  ​\t\t-XX:NewRatio=4，新生代占1，老年代4，年轻代占整个堆的1/5。\n\n- -XX:MaxTenuringThreshold 设置垃圾的最大年龄\n\n  默认值为15，超过这个值后对象由新生代转移至老年代\n\n  java8设置值必须在0-15\n\n#### 4.强引用、软引用、弱引用、虚引用分别是什么？\n\n- 强引用\n\n  默认的引用，大部分引用都是强引用\n\n  *当内存不足时，JVM开始垃圾回收，对于强引用的对象，**就算是出现了OOM也不会对该对象进行回收**。\n\n  强引用是我们最常见的普通对象引用，只要强引用指向一个对象，就能表明对象还“或者”，垃圾收集器不会回收这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用类型就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，**即使该对象以后永远都不会被用到JVM也不会回收**。因此强引用是造成Java内存泄漏的主要原因之一。\n\n  对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null,一般认为就是可以被垃圾收集的了（当然具体回收时机还是看垃圾收集策略）。\n\n- 软引用\n\n","categories":["JVM"]},{"title":"深入理解JVM","url":"/2018/11/16/深入理解JVM/","content":"### 1.类加载\n\n![](/images/jvm/类加载及对象实例化.png)\n\n#### 1.1 概念\n\n在java代码中，**类型**(不是对象)的加载、连接与初始化过程都是在程序运行期间完成的。\n\n这样提供了更大的灵活性，增加了更多的可能性。\n\n#### 1.2 生命周期\n\n 在如下情况下下，Java虚拟机将结束生命周期：\n\n- 执行了System.exit()方法\n\n    - 程序正常执行结束\n    - 程序在执行过程中遇到了异常或错误而异常终止\n    - 由于操作系统出现错误而导致Java虚拟机进程终止\n\n#### 1.3 类的加载、连接与初始化\n\n##### 1.3.1 类的加载\n\n- 类的加载指的是将类的.class文件的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（虚拟机规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区的数据结构。**类的加载的最终产品是位于内存中的Class对象**，Class对象封装了类在方法区的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。\n\n- 加载.class文件的方式：\n\n  - 从本地系统中直接加载\n  - 通过网络下载.class文件\n  - 从zip,jar等归档文件中加载.class文件\n  - 从专有数据库中提取.class文件\n  - **将Java源文件动态编译成.class文件（动态代理）**\n\n- 两种类型的类加载器\n\n  - Java虚拟机自带的类加载器\n    - 根类加载器（BootStrap）\n    - 扩展类加载器（Extension）\n    - 系统（应用）类加载器（System）\n  - 用户自定义的类加载器\n    - java.lang.ClassLoader的子类\n    - 用户可以定制类的加载方式\n\n  ​    类加载器并不需要等到某个类被\"首次主动使用\"时再加载它；\n\n  ​    JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件确实或者存在错误，类加载器必须在**程序首次主动**使用该类时才报告错误（LinkageError错误）；\n\n  ​    如果这个类一直没有被程序主动使用，那么**类加载器就不会报告错误**；\n\n- **类加载器的双亲(父亲)委托机制**\n\n  ​    在双亲委托机制中，各个加载器按照父子关系 形成了**树形结构(逻辑上的树形结构，不是继承上的)**，除了根类加载器之外，其余的类加载器有且只有一个父加载器；\n\n  ​    双亲委托机制：\n\n      - 自底向上检查类是否已被加载；\n      - 自上到下尝试加载类；\n\n  ​    \n\n##### 1.3.2 连接\n\n- 验证：确保被加载类的正确性；\n- 准备：为类的**静态变量**分配内存，并将其初始化为**默认值**；\n- 解析：**把类中的符号引用转换为直接直接引用**；\n\n##### 1.3.3 初始化\n\n**类的初始化：为类的静态变量赋予正确的初始值**\n\nJava程序对类的使用方式可以分为两种：\n\n- 主动使用\n\n  - 创建类的实例\n\n  - 访问某个类或接口的静态变量，或者对该静态变量赋值\n\n  - 调用类的静态方法\n\n  - 反射\n\n  - 初始化一个类的子类则父类先被初始化\n\n  - Java虚拟机启动时被标记为启动类的类\n\n  - JDK1.7开始提供的动态语言支持：\n\n    java.lang.invoke.MethodHandle实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化。\n\n- 被动使用\n\n所有Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才初始化他们；\n\nexample1:\n\n```java\npackage com.lixiang.jvm.classloader;\n\n/*\n通过子类访问父类中定义的静态变量，则父类被初始化而子类不会被初始化；而访问子类直接定义的静态变量时，父类先被初始化并且子类也被初始化。\n*/\n\npublic class MyTest1 {\n    public static void main(String[] args) {\n        System.out.println(MyChild1.str1);\n        //System.out.println(MyChild1.str2);\n    }\n}\n\nclass MyParent1{\n    static String str1= \"MyParent1\";\n    static {\n        System.out.println(\"MyParent1 static block\");\n    }\n}\n\nclass MyChild1 extends MyParent1{\n    static String str2= \"MyChild1\";\n    static {\n        System.out.println(\"MyChild1 static block\");\n    }\n}\n```\n\nexample2:\n\n```java\npackage com.lixiang.jvm.classloader;\n\n/*\n常量在编译阶段会被存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化\n注意：这里指的是将常量存放到了MyTest2的常量池中(调用类),之后MyTest2与MyParent2就没有任何关系了，甚至，我们可以将MyParent2的class文件删除\n*/\n\npublic class MyTest2 {\n    public static void main(String[] args) {\n        System.out.println(MyParent2.str);\n    }\n}\n\nclass MyParent2{\n    public static final String str = \"hello world\";\n\n    static {\n        System.out.println(\"MyParent2 static block\");\n    }\n}\n```\n\n​    执行javap -c  MyTest2.class反编译，可以看到：\n\n```txt\npublic class com.lixiang.jvm.classloader.MyTest2 {\n  public com.lixiang.jvm.classloader.MyTest2();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #4                  // String hello world\n       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n\n其中助记符ldc表示：将int，float或者是String类型的常量值从常量池中推送至栈顶\n\nps助记符: \n\n​\tbipush 表示将单字节(-128 ~ 127)的常量值推送至栈顶,如short;\n\n​\tsipush 表示将一个短整型常量池(-32768 ~ 32767)的常量值推送至栈顶;\n\n​\ticonst_1 表示将int类型的1推送至栈顶(iconst_m1 ~ iconst_5);\n\n\n\nexample3:\n\n```java\npackage com.lixiang.jvm.classloader;\n\nimport java.util.UUID;\n/*\n当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中\n这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化\n*/\npublic class MyTest3 {\n    public static void main(String[] args) {\n        System.out.println(MyParent3.str);\n    }\n}\n\nclass MyParent3{\n    public static final String str = UUID.randomUUID().toString();\n\n    static {\n        System.out.println(\"MyParent3 ststic block\");\n    }\n}\n```\n\nexample4:\n\n```java\npackage com.lixiang.jvm.classloader;\n/*\n不会执行MyParent4的静态代码块\n对于数组实例来说，其类型是由JVM在运行期间动态生成的，表[Lcom.lixiang.jvm.classloader.MyParent4这种形式。动态形成的类型，其父类型就是Object\n*/\npublic class MyTest4 {\n    public static void main(String[] args) {\n        //MyParent4 myParent4 = new MyParent4();\n        MyParent4[] myParent4s = new MyParent4[1];\n        System.out.println(myParent4s.getClass());\n        System.out.println(myParent4s.getClass().getSuperclass());\n\n        System.out.println(\"========\");\n        int[] ints = new int[1];\n        System.out.println(ints.getClass());\n        System.out.println(ints.getClass().getSuperclass());\n    }\n}\n\nclass MyParent4{\n    static {\n        System.out.println(\"MyParent4 static block\");\n    }\n}\n```\n\n反编译：\n\n```txt\npublic class com.lixiang.jvm.classloader.MyTest4 {\n  public com.lixiang.jvm.classloader.MyTest4();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: iconst_1\n       1: anewarray     #2                  // class com/lixiang/jvm/classloader/MyParent4\n       4: astore_1\n       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       8: aload_1\n       9: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n      12: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n      15: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      18: aload_1\n      19: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n      22: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;\n      25: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n      28: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      31: ldc           #7                  // String ========\n      33: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n      36: iconst_1\n      37: newarray       int\n      39: astore_2\n      40: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      43: aload_2\n      44: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n      47: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n      50: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n      53: aload_2\n      54: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;\n      57: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;\n      60: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n      63: return\n}\n\n```\n\nps助记符：\n\n​\tanewaray：表示创建一个引用类型（如类、接口、数组）的数组，并将其引用值压入栈顶；\n\n​\tnewarray：表示创建一个指定的原始类型（如int、float、char等）的数组，并将其引用值压入栈顶；\n\n- 初始化对于类与接口的异同点\n\n  当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口：\n\n  - 在初始化一个类时，并不会先初始化它所实现的接口；\n  - 在初始化一个接口时，并不会先初始化它的父接口；\n\n  因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。\n\n#### 1.4 JVM参数\n\n- -XX:+<option> ,表示开启option选项；\n- -XX:-<option> ,表示关闭option选项；\n- -XX:<option>=<value> ,表示将option选项的值设置为vlaue；\n\n"},{"title":"Java并发","url":"/2018/10/25/Java并发/","content":"### 栅栏模式\n\n#### CountDownLatch\n\n  减计数器：计数器减到0时，继续执行。即计数器在多个线程内依次减到0时，被减计数器栓等待的线程才会继续向下执行。\n\n  demo:\n\n  ```java\n  package com.lixiang.concurrent.barrier;\n  \n  import java.util.Random;\n  import java.util.concurrent.CountDownLatch;\n  \n  public class CountDownDemo {\n  \n      private static final int N = 10;\n  \n      public static void main(String[] args) throws InterruptedException {\n  \n          CountDownLatch countDownLatch = new CountDownLatch(N);\n  \n          for (int i = 0; i <N ; i++) {\n              new Thread(() -> {\n                  try {\n                      Thread.sleep(new Random().nextInt(5000));\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }\n                  System.out.println(Thread.currentThread().getName()+\"完成准备工作\");\n                  countDownLatch.countDown();\n              },String.valueOf(i)).start();\n          }\n  \n          countDownLatch.await();\n          System.out.println(Thread.currentThread().getName()+N+\"个准备工作全部完成，开始执行真正的任务\");\n      }\n  }\n  ```\n\n  \n\n#### CyclicBarrier\n\n  循环(复用)栅栏：当在栅栏外的任务数达到规定的数目时，就放行目标任务一次，可以多次复用。\n\n  demo:\n\n  ```java\n  package com.lixiang.concurrent.barrier;\n  \n  import java.util.concurrent.BrokenBarrierException;\n  import java.util.concurrent.CyclicBarrier;\n  \n  public class CyclicBarrierDemo {\n      public static void main(String[] args) {\n          CyclicBarrier cyclicBarrier = new CyclicBarrier(7,\n                  () -> System.out.println(\"召唤神龙\"));\n  \n          for (int i = 0; i < 7; i++) {\n              final int temp = i + 1;\n              new Thread(() -> {\n                  System.out.println(\"收集到第\" + temp + \"颗龙珠\");\n                  try {\n                      cyclicBarrier.await();\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  } catch (BrokenBarrierException e) {\n                      e.printStackTrace();\n                  }\n              }, String.valueOf(i)).start();\n          }\n      }\n  }\n  ```\n\n  \n\n#### Semaphore\n\n  信号灯：信号量主要用于两个目的，一个是用于<b>多个</b>共享资源的互斥使用，另一个用于并发线程数的控制；\n\n  类比：多辆车抢多个车位\n  \n  demo:\n  \n  ```java\n  package com.lixiang.concurrent.barrier;\n  \n  import java.util.concurrent.Semaphore;\n  import java.util.concurrent.TimeUnit;\n  \n  public class SemaphoreDemo {\n  \n      public static void main(String[] args) {\n          //模拟3个车位\n          Semaphore semaphore = new Semaphore(3);\n          for (int i = 0; i < 6; i++) {\n              new Thread(() -> {\n                  try {\n                      semaphore.acquire();\n                      System.out.println(Thread.currentThread().getName()+\"\\t抢到车位\");\n                      TimeUnit.SECONDS.sleep(3);\n                      System.out.println(Thread.currentThread().getName()+\"\\t停留3秒后离开车位\");\n                  } catch (InterruptedException e) {\n                      e.printStackTrace();\n                  }finally {\n                      semaphore.release();\n                  }\n              },String.valueOf(i)).start();\n          }\n      }\n  }\n  ```\n  \n  \n\n### 阻塞队列\n\n#### （1）阻塞队列什么时候是有好处的(一般阻塞是不好的)？\n\n​\t\t比如：火锅店，来了就是客，欢迎在休闲区等待，一旦有空位客人立马可以就坐；\n\n#### （2）不得不阻塞的时候怎么管理\n\n#### （3）阻塞队列的特性\n\n​\t\t当阻塞队列是**空**的时候，从队列里面**获取**元素的操作将会被阻塞；\n\n​\t\t当阻塞队列是**满**时，往队列里面**添加**元素的操作会被阻塞；\n\n​\t\t![BlockingQueue](/images/concurrent/BlockingQueue.png)\n\n​\t\t在多线程领域，所谓阻塞，在某些情况下会**挂起**线程（即阻塞），一旦条件满足，被挂起的线程又会被**唤醒**。\n\n#### （4）为什么需要BlockingQueue?\n\n​\t\t好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，利用阻塞队列可以轻松实现相同的效果。在concurent包发布之前，在多线程环境下，**程序员需要自己去控制这些细节，尤其是还要兼顾效率和线程安全**，而这样会给多线程程序的开发带来不小的复杂性。\n\n#### （5）阻塞队列类型\n\n- **ArrayBlockingQueue：由数组结构实现的有界阻塞队列(相当于阻塞的ArrayList)；**\n- **LinkedBlockingQueue:由链表结构实现的有界（但大小默认值是Integer.MAX.VALUE，所以慎用）阻塞队列；**\n- PriorityBlockingQueue：支持优先级排序的无界阻塞队列；\n- DelayQueue：使用优先级队列实现的延迟无界阻塞队列；\n- **SynchronousQueue：不储存元素的阻塞队列，也即单个元素的队列；**\n- LinkedTransferQueue：由链表结构组成的无界阻塞队列；\n- LinkedBlockingDeque：由链表结构组成的双向阻塞队列。\n\n#### （6）BlockingQueue的核心方法\n\n| 方法类型 | 抛出异常  |  特殊值  |  阻塞  |        超时         |\n| :------: | :-------: | :------: | :----: | :-----------------: |\n|   插入   |  add(e)   | offer(e) | put(e) | offter(e,time,unit) |\n|   移除   |  remove   |  poll()  | take() |   poll(time,unit)   |\n|   检查   | element() |  peek()  | 不可用 |       不可用        |\n\n| 类型     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| 抛出异常 | 当阻塞队列满时，再往队列里add插入元素会抛出IllegalStateException:Queue full<br />当阻塞队列为空时，再从队列里remove移除元素会抛出NoSuchElementExcaption |\n| 特殊值   | 插入方法，成功true失败false<br />移除方法，成功返回队列的元素，队列里面没有元素返回null |\n| 一直阻塞 | 当阻塞队列满时，生产者线程继续往队列里面put元素，队列会一直阻塞生产线程直到take元素或者中断退出<br />当阻塞队列空时，消费者线程试图从线程里take元素，队列会一直阻塞消费者线程直到队列可用 |\n| 超时阻塞 | 当阻塞队列满时，生产者线程继续往队列里面offer元素，队列会阻塞生产线程直到在规定时间内队列可用<br />当阻塞队列空时，消费者线程试图从线程里poll元素，队列会阻塞消费者线程直到在规定时间内队列可用 |\n\n#### （7）阻塞队列的用处\n\n- 生产者消费者模式\n  - 传统版\n  \n  ```java\n  package com.lixiang.concurrent.blockingQueue;\n  \n  import java.util.concurrent.locks.Condition;\n  import java.util.concurrent.locks.Lock;\n  import java.util.concurrent.locks.ReentrantLock;\n  \n  /**\n   * @author lixiang\n   * @create 2019-05-09 0:10\n   */\n  \n  class ShareData {\n      private Integer num = 0;\n      private Lock lock = new ReentrantLock();\n      private Condition condition = lock.newCondition();\n  \n      public void increment() {\n          lock.lock();\n          //判断\n          try {\n              while (num != 0) {\n                  //1.等待，不能生产\n                  condition.await();\n              }\n              //2.干活\n              num++;\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + num);\n              //3.通知唤醒\n              condition.signalAll();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }finally {\n              lock.unlock();\n          }\n      }\n  \n      public void decrement() {\n          lock.lock();\n          //判断\n          try {\n              while (num == 0) {\n                  //1.等待，不能消费\n                  condition.await();\n              }\n              //2.干活\n              num--;\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + num);\n              //3.通知唤醒\n              condition.signalAll();\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }finally {\n              lock.unlock();\n          }\n      }\n  }\n  \n  public class TradationalProConDemo {\n      public static void main(String[] args) {\n          ShareData shareData = new ShareData();\n  \n          new Thread(() -> {\n              for (int i = 0; i < 5; i++) {\n                  shareData.increment();\n              }\n          },\"AA\").start();\n  \n          new Thread(() -> {\n              for (int i = 0; i < 5; i++) {\n                  shareData.decrement();\n              }\n          },\"BB\").start();\n      }\n  }\n  ```\n  \n  - ps：synchronized和Lock的区别\n  \n    1. 原始构成：\n  \n       synchronized是关键字，属于JVM层面，底层有两步动作：monitorenter(底层是通过monitor对象来完成)，monitorexit，其实wait/nofity/notifyAll也依赖于monito对象，所以wait/notify/notifyAll必须写在同步代码块里面；\n  \n       Lock是具体的类（接口，java.util.concurrent.locks.Lock）：是API层面的锁。\n  \n    2. 使用方法\n  \n       synchrozined不需要手动去释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用；\n  \n       ReentrantLock需要用户去手动释放锁，若没有主动去释放锁就可能导致出现死锁现象，需要lock()和unlock()配合try/finally语句块来完成。\n  \n    3. 等待是否可中断\n  \n       synchronized不可中断，除非抛出异常或者正常运行完成；\n  \n       ReentrantLock可中断：1）设置超时方法 tryLock(long timeout, TimeUnit unit)；\n  \n       ​\t\t\t\t\t\t\t\t\t\t 2）使用lock.lockInterruptibly()，调用interrupt()方法可中断。\n  \n    4. 加锁是否公平\n  \n       synchronized是非公平锁；\n  \n       ReentrantLock默认是非公平锁，但其构造方法中可以传入boolean值，true为公平锁，false为非公平锁。\n  \n    5. 锁绑定多个条件Condition\n  \n       synchronized没有\n  \n       ReentrantLock可以实现分组唤醒需要唤醒的线程们，可以精确唤醒，而synchronized要么随机唤醒一个要么全部唤醒。\n  \n       demo：多线程之间按顺序调用，实现A-B-C，要求：AA线程打印5次，BB线程打印10次，CC线程打印15次，然后总共循环10次：\n  \n       ```java\n       package com.lixiang.concurrent.blockingQueue;\n       \n       import java.util.concurrent.locks.Condition;\n       import java.util.concurrent.locks.Lock;\n       import java.util.concurrent.locks.ReentrantLock;\n       \n       class ShareResource {\n       \n           private int num = 1;\n           private Lock lock = new ReentrantLock();\n           private Condition c1 = lock.newCondition();\n           private Condition c2 = lock.newCondition();\n           private Condition c3 = lock.newCondition();\n       \n           public void print5() {\n               lock.lock();\n               try {\n                   while (num != 1) {\n                       c1.await();\n                   }\n                   for (int i = 0; i < 5; i++) {\n                       System.out.println(Thread.currentThread().getName() + \"\\t\" + num);\n                   }\n                   num = 2;\n                   c2.signal();\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               } finally {\n                   lock.unlock();\n               }\n           }\n       \n           public void print10() {\n               lock.lock();\n               try {\n                   while (num != 2) {\n                       c2.await();\n                   }\n                   for (int i = 0; i < 10; i++) {\n                       System.out.println(Thread.currentThread().getName() + \"\\t\" + num);\n                   }\n                   num = 3;\n                   c3.signal();\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               } finally {\n                   lock.unlock();\n               }\n           }\n       \n           public void print15() {\n               lock.lock();\n               try {\n                   while (num != 3) {\n                       c3.await();\n                   }\n                   for (int i = 0; i < 15; i++) {\n                       System.out.println(Thread.currentThread().getName() + \"\\t\" + num);\n                   }\n                   num = 1;\n                   c1.signal();\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               } finally {\n                   lock.unlock();\n               }\n           }\n       }\n       \n       public class ReentrantLockDemo {\n           public static void main(String[] args) {\n               ShareResource shareResource = new ShareResource();\n       \n               new Thread(() -> {\n                   for (int i = 0; i < 10; i++) {\n                       shareResource.print5();\n                   }\n               }, \"AA\").start();\n       \n               new Thread(() -> {\n                   for (int i = 0; i < 10; i++) {\n                       shareResource.print10();\n                   }\n               }, \"BB\").start();\n       \n               new Thread(() -> {\n                   for (int i = 0; i < 10; i++) {\n                       shareResource.print15();\n                   }\n               }, \"CC\").start();\n           }\n       }\n       ```\n  \n       \n  \n  - 阻塞队列版\n  \n    ```java\n    package com.lixiang.concurrent.blockingQueue;\n    \n    import java.util.concurrent.ArrayBlockingQueue;\n    import java.util.concurrent.BlockingQueue;\n    import java.util.concurrent.TimeUnit;\n    import java.util.concurrent.atomic.AtomicInteger;\n    \n    /**\n     * @author lixiang\n     * @create 2019-05-09 16:29\n     */\n    class ConcurrentData {\n        //生产消费开始结束标识，true为生产消费，false为停止\n        private volatile boolean flag = true;\n        private AtomicInteger atomicInteger = new AtomicInteger();\n        BlockingQueue<String> blockingQueue = null;\n        \n        public ConcurrentData(BlockingQueue<String> blockingQueue) {\n            this.blockingQueue = blockingQueue;\n        }\n    \n        public void produce() {\n            String data = null;\n            boolean retFlag;\n            try {\n                while (flag) {\n                    data = atomicInteger.incrementAndGet() + \"\";\n                    retFlag = blockingQueue.offer(data, 2, TimeUnit.SECONDS);\n                    if (retFlag) {\n                        System.out.println(Thread.currentThread().getName() + \"\\t插入队列插入\" + data + \"成功\");\n                    } else {\n                        System.out.println(Thread.currentThread().getName() + \"\\t插入队列插入\" + data + \"失败，队列已满\");\n                    }\n                    /*这里暂停1秒只是为了看得清楚,不暂停的话实际情况应该是一直不停的生产消费,每秒\n                    几万次(生产消费输出顺序也会有一点点错乱,但是只是多线程导致的输出时\n                     序和生产消费一点不一样，但生产消费是对的，即先生产再消费)\n                     */\n                    TimeUnit.SECONDS.sleep(1);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n    \n        }\n    \n        public void consume() {\n            String result = null;\n            try {\n                while (flag) {\n                    result = blockingQueue.poll(2, TimeUnit.SECONDS);\n                    if (null == result || \"\".equals(result)) {\n                        flag = false;\n                        System.out.println(Thread.currentThread().getName() + \"\\t超过两秒没有取到队列的值，消费退出\");\n                        return;\n                    }\n                    System.out.println(Thread.currentThread().getName() + \"\\t消费队列取出\" + result + \"成功\");\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    \n        public void stop() {\n            flag = false;\n        }\n    }\n    \n    public class BlockingProConDemo {\n    \n        public static void main(String[] args) throws InterruptedException {\n            ConcurrentData concurrentData = new ConcurrentData(new ArrayBlockingQueue<>(10));\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \"\\t生产者线程启动，开始生产\");\n                System.out.println();\n                concurrentData.produce();\n            }, \"生产者\").start();\n    \n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \"\\t消费者线程启动，开始消费\");\n                System.out.println();\n                concurrentData.consume();\n            }, \"消费者\").start();\n    \n            TimeUnit.SECONDS.sleep(5);\n            System.out.println();\n            System.out.println(\"5秒后下令停止生产和消费过程\");\n            concurrentData.stop();\n        }\n    }\n    ```\n  \n    \n  \n- 线程池\n\n  - 为什么使用线程池，优势\n\n    ​    线程池做的工作主要是控制运行的线程的数量，**处理过程中将任务放入队列**，然后在线程创建后启动这些任务，**如果线程数量超过了最大数量超出数量的线程排队等候**，等其他线程执行完毕，再从队列中取出任务来执行。\n\n    ​    线程池的主要特点是：**线程复用；控制最大并发量；管理线程。**\n\n    好处\n\n    - 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的开销。\n    - 提高响应速度。当任务到达时，任务可以不需要等待创建线程而立即执行。\n    - 提高线程的可管理性。线程是稀缺资源，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n    ​    \n\n  - 线程池如何使用\n\n    线程池的顶层接口:\n\n    ![](/images/concurrent/ThreadPoolExecutor.png)\n\n    5种线程池：\n\n    ​\t**Executors.newFixedThreadPool(int nThreads)**:一池多个(固定)处理线程，适用于执行长期任务，性能好很多；\n\n    ​\t**Executors.newSingleThreadExecutor()**：一池一个处理线程，适用于一个任务一个任务执行的场景；\n\n    ​\t**Executors.newCachedThreadPool**一池N个处理线程，适用于执行很多短期异步的小程序或者负载较轻的服务；\n\n    ​\tExecutors.newSingleThreadScheduledExecutor()；\n\n    ​\tExecutors.newScheduledThreadPool(int corePoolSize)；\n\n  - 线程池的几个重要参数介绍\n\n    7大参数(底层7，呈现出来5):\n\n    5参数:\n\n    ```java\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n            return new ThreadPoolExecutor(nThreads, nThreads,\n                                          0L, TimeUnit.MILLISECONDS,\n                                          new LinkedBlockingQueue<Runnable>());\n    }\n    \n    public ThreadPoolExecutor(int corePoolSize,\n                                  int maximumPoolSize,\n                                  long keepAliveTime,\n                                  TimeUnit unit,\n                                  BlockingQueue<Runnable> workQueue) {\n            this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n                 Executors.defaultThreadFactory(), defaultHandler);\n    }\n    ```\n\n    7参数:\n\n    ```java\n    public ThreadPoolExecutor(int corePoolSize,\n                                  int maximumPoolSize,\n                                  long keepAliveTime,\n                                  TimeUnit unit,\n                                  BlockingQueue<Runnable> workQueue,\n                                  ThreadFactory threadFactory,\n                                  RejectedExecutionHandler handler) {\n            if (corePoolSize < 0 ||\n                maximumPoolSize <= 0 ||\n                maximumPoolSize < corePoolSize ||\n                keepAliveTime < 0)\n                throw new IllegalArgumentException();\n            if (workQueue == null || threadFactory == null || handler == null)\n                throw new NullPointerException();\n            this.acc = System.getSecurityManager() == null ?\n                    null :\n                    AccessController.getContext();\n            this.corePoolSize = corePoolSize;\n            this.maximumPoolSize = maximumPoolSize;\n            this.workQueue = workQueue;\n            this.keepAliveTime = unit.toNanos(keepAliveTime);\n            this.threadFactory = threadFactory;\n            this.handler = handler;\n    }\n    ```\n\n    7大参数简介:\n\n    - corePoolSize：线程池中的常驻核心线程数；\n    - maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1；\n    - keepAliveTime：多余的空闲线程的存活时间，当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止；\n    - unit：keepAliveTime的单位；\n    - workQueue：任务队列，用于存放被提交但尚未执行的任务；\n    - threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，**一般用默认的即可**\n    - handler：拒绝策略：表示当队列满了并且工作线程大于等于线程池的最大线程池(maximumPoolSize)时如何来拒绝任务；\n\n  - **线程池的工作原理**\n\n    原理图:\n\n    I.\n\n    ![](/images/concurrent/线程池工作原理.png)\n\n    II.\n\n    ![](/images/concurrent/线程池的处理流程.png)\n\n    **流程**：\n\n    1. 在创建了线程池后，等待提交过来的任务请求；\n\n    2. 当调用execute()方法添加一个请求任务时，线程池会做以下判断：\n\n       2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；\n\n       2.2 如果正在运行的数量大于或等于corePoolSize，那么将这个任务放入任务队列；\n\n       2.3 如果这个时候队列满了且正在运行的线程数量还小于maxinumPoolSize，那么还是创建线程立即运行这个任务；\n\n       2.4 如果队列满了且正在运行的线程数量大于或等于maxinumPoolSize，那么线程池后启动饱和拒绝策略；\n\n    3. 当一个线程完成任务时，它从队列中取出下一个任务来执行；\n\n    4. 当一个线程无事可做超过一定的时间(keepAliveTime)时，线程池会判断：\n\n       如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉，所以线程池的所有任务完成后它**最终会收缩到corePoolSize的大小**；\n","categories":["Java并发"]},{"title":"CentOS7安装npm和使用cnpm","url":"/2018/04/20/CentOS安装npm和使用cnpm/","content":"### 1.安装npm\n\nnpm命令是node.js的npm 插件管理器，也就是下载插件安装插件的管理器。\n\n安装命令:\n\n```shell\nyum install nodejs\n```\n\n若报错:没有可用软件包 nodejs。\n\n则先下载epel-release\n\n```shell\nyum install epel-release\n```\n\n安装成功后可查看版本:\n\n```shell\nnpm -v\n```\n\n或:\n\n```shell\nnode -v\n```\n\n### 2.使用淘宝的cnpm\n\n因为npm下载都是国外服务器很慢会掉线，我们需要使用淘宝的npm镜像cnpm。\n\n命令：\n\n```shell\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n之后就可以使用cnpm下载(将npm命令替换为cnpm即可)\n","categories":["linux","安装配置"]},{"title":"CentOS7更换yum源","url":"/2018/04/15/CentOS更换yum源/","content":"\n### 1.备份\n\n进入yum.repo.d目录下将原来的文件重命名备份\n\n```shell\ncd /etc/yum.repos.d\nmv CentOS-Base.repo CentOS-Base.repo.backup\n```\n\n### 2.下载yum源\n\nsohu的源：<http://mirrors.sohu.com/help/CentOS-Base-sohu.repo>\n\n163的源：<http://mirrors.163.com/.help/CentOS6-Base-163.repo>\n\n阿里云的源：<http://mirrors.aliyun.com/repo/Centos-7.repo> \n\n例如更换为阿里云的yum源:\n\nCentOS7:\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\nCentOs6:\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo\n```\n\n### 3.更新yum源\n\n```shell\nyum update\n```\n\n### 4.更新yum源不更新内核\n\n若更新yum源时不想更新系统内核，则有两种方案：\n\n- **修改yum的配置文件**\n\n  ```shell\n  vim /etc/yum.conf\n  #在最后添加\n  exclude=kernel*\n  exclude=centos-release*\n  ```\n\n- **直接在yum的命令后面加上如下的参数**\n\n  ```shell\n  yum --exclude=kernel* update\n  ```\n\n  \n","categories":["linux","安装配置"]},{"title":"深入剖析HashMap","url":"/2018/03/28/深入剖析HashMap/","content":"## 1.为什么需要HashMap？用处？\n\n首先，Map是一个映射键和值的对象，类似于字典(Python中就有字典的概念)。\n\n如果不考虑Map，我们常用的储存元素的容器大多是数组和链表。数组储存元素的好处在于根据下标查找元素迅速，因为不需要遍历元素，但其增加或删除元素却需要移动大量元素，因此数组在增删上性能不好(ArrayList也是一样的道理，本质也是数组)。而链表由于底层数据结构采用Node节点相连接，因此增删元素往往只涉及元素自身及其前后节点的操作，非常方便和快速，但其查找元素时需要遍历链表直到找到指定的元素为止，因此在需要大量的查找操作时链表性能往往不佳。\n\n那么能不能有一种数据结构，能够满足查找和增删元素都非常快速？这个时候就出现了哈希表这种数据结构，相对而言，哈希表查询没数组快，插入没链表快，但却综合了两者的优点，在各个方面性能都能表现得比较好。\n\n而HashMap就是一个哈希表的实现，在JDK1.8中，HashMap底层采用了**数组+链表+红黑树**实现，能够实现快速的查找和插入。HashMap能够根据键值快速的查找到相应的值，也能够根据要插入的值快速的定位插入，类似于前面说的字典的概念。\n\n## 2.HashMap的底层实现\n\nHashMap底层采用**数组+链表+红黑树**实现，当往HashMap中插入键值对时，会根据key值的hashcode经过处理之后找到在**哈希桶**(即HashMap底层的数组)中对应的桶位置，将键值对(封装为**Node**元素)保存在桶中，若之后新添加的元素计算得出的位置已保存有元素时，则以**单向链表**的形式将新Node挂载到链表尾部，当链表中的元素个数超过阈值时单向链表会转换为**红黑树**。而查找元素时也是根据key值的hashcode找到对应的桶位置，再将key值与桶中链表或红黑树中的元素比较找出相等的key值，就找到了要查找的键值对，这样根据key值查找value值不需要遍历桶中所有的元素，根据key值的hashcode直接定位到对应的桶位置，再遍历桶中的链表比较即可找到要查找的元素。这样键值对的插入与查找性能都比较好。\n\nHashMap示意图(未涉及红黑树时):\n\n![](/images/watermark/collection/HashMap.png)\n\n首先，看一下HashMap封装的数据结构：\n\n- Hash桶\n\n```java\n//HashMap中的节点数组，即Hash桶，用于存放元素链表或红黑树\ntransient Node<K,V>[] table;\n```\n\nHash桶是HashMap中用于存放元素链表或红黑树的数组，看一下Node节点的定义：\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    \t//处理后的hash码，可以标识key的位置\n        final int hash;\n    \t//key值\n        final K key;\n    \t//value值\n        V value;\n    \t//下一节点\n        Node<K,V> next;\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n\n可以看出，Node是一个单向链表的节点，当往HashMap中存放元素时，实际是往数组中保存Node对象，当一个桶中保存多个Node时，其实保存的是一个单向链表(桶中Node数量超过8时链表会转换为红黑树)。\n\n下面再看一下HashMap中定义的一些变量或常量：\n\n```java\n//默认容量，16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n//最大容量\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n//默认装载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n//阈值，当桶节点数量大于等于8时桶中保存的链表转换为红黑树\nstatic final int TREEIFY_THRESHOLD = 8;\n//阈值，当桶节点数量变为小于等于6时桶中保存的红黑树转换为链表\nstatic final int UNTREEIFY_THRESHOLD = 6;\n//当需要将桶中链表转换为红黑树时整个HashMap的最小容量值\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n//已保存的key-value键值对的个数\ntransient int size;\n//已保存的key-value达到此阈值时需要调整容量大小(=capacity * load factor)\nint threshold;\n//哈希表的装载因子，计算threshold\nfinal float loadFactor;\n```\n\n可以看出：\n\n- 整体上，HashMap定义了其默认容量、最大容量，以及需要调整容量时的阈值。\n- 单个桶来说，定义了key-value的Node<K,V>的链表的阈值TREEIFY_THRESHOLD，超过此阈值时相应桶中的链表就需要转换为红黑树，以适应快速查找的要求；同时，当删除key-value时，桶中Node<K,V>数量减少,若桶中节点数量由8(TREEIFY_THRESHOLD)减少为6(UNTREEIFY_THRESHOLD)，则红黑树需要再转换为单向链表。\n\n有2个重要的特性影响着HashMap的性能，分别是capacity(容量)和load factor(加载因子)。\n\n其中capacity表示哈希表bucket的数量，HashMap的默认值是16。load factor加载因子表示当一个map填满了达到这个比例之后的bucket时候，和ArrayList一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程也叫做重哈希。默认的load factor为0.75 。\n\n这样，HashMap就利用**数组+单向链表+红黑树**实现了key-value的快速增删查改。至于实现的细节，接下来分为几个部分分开阐述。\n\n## 3.构造一个HashMap发生了什么\n\n前面介绍了HashMap的底层数据结构以及一些变量和常量的意义，那么当我们使用HashMap时，其底层细节究竟是怎么实现的？\n\n### 3.1.无参的HashMap\n\n先从无参构造(不指定容量),创建一个HashMap对象:\n\n```java\nMap<String,String> map = new HashMap<>();\n```\n\nnew一个HashMap是简单的，看一下源码的调用:\n\n```java\npublic HashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n    }\n```\n\n只是指定了装载因子为默认的装载因子(0.75f)，加上之前的介绍，可以知道我们会得到一个初始容量为16，装载因子为0.75的HashMap。\n\n### 3.2.指定初始容量\n\n创建一个HashMap对象，指定初始容量：\n\n```java\nHashMap<String, String> hashMap = new HashMap<>(5);\n```\n\n跟踪源码调用过程:\n\n```java\npublic HashMap(int initialCapacity) {\n    \t//装载因子为默认装载因子(0.75f)\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n```\n\n调用了有参构造函数:\n\n```java\n public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n     \t//初始化装载因子\n        this.loadFactor = loadFactor;\n     \t//指定阈值\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n\n可以看出HashMap的阈值调用了内部方法tableSizeFor(int cap)：\n\n```java\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n上面这个方法最终使得 阈值 = 大于或等于指定容量的最小的2的整数次方，例如：\n\n- 指定初始容量为3，则初始化阈值为4\n- 指定初始容量为5，则初始化阈值为8\n- ......\n\n以5举例,=0101：\n\n```text\nint n = 5-1 = 4;\nn = n | (n>>>1) = 0101 | 0010 = 0111 = 7\nn = n | (n>>>2) = 0111 | 0001 = 0111 = 7\nn = n | (n>>>4) = 0111 | 0000 = 0111 = 7\nn = n | (n>>>8) = 00000111 | 00000000 = 7\nn = n | (n>>>16) = 00000111 | 00000000 = 7\nreturn n+1(8);\n```\n\n返回后，HashMap的构造方法就完成了,一共做了两件事：\n\n- 指定装载因子为默认装载因子(0.75)\n- 初始化阈值 = 大于或等于指定容量的最小的2的整数次方(或者MAXIMUM_CAPACITY)或1)\n\n无论无参构造方法还是指定初始容量，可以看出来，**只是初始化了阈值threshold及装载因子loadFactor，并没有初始化底层节点数组 Node<K,V>[] table**。\n\n## 4.HashMap的put\n\n前面看到了HashMap底层采用**数组+单向链表+红黑树(还没讨论)**，而创建一个HashMap对象时，也只会初始化其装载因子和阈值，下面看一下当使用HashMap的put(K,V)方法时经历了哪些过程。\n\n```java\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n```\n\n### 4.1.hash算法扰动函数\n\n调用put(K,V)方法时，内部调用了put(int hash, K key, V value,  boolean onlyIfAbsent, boolean evict)，然而调用这个方法之前可以看出第一个参数也调用了内部方法计算hash值:\n\n```java\nstatic final int hash(Object key) {\n        int h;\n    \t// 使用hashCode的值和hashCode的值无符号右移16位做异或操作\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n我们知道，对象的hashCode值是根据我们自定义的hashcode()方法生成的32位整型数字，而从上面的方法可以看出来，HashMap中Node中的hash值 =  (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)，即利用了key的hashcode的低16位与高16位做异或运算，那么为什么需要这么做呢？\n\n我们知道，HashMap存放数据的时候需要利用key的hash值与（哈希桶容量-1）做与(&)运算，进而算出数据需要储存在哈希桶的什么位置。(后面会提到，先看其中一点源码)\n\n```java\nNode<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n```\n\n而哈希桶容量刚开始是比较小的，随着其动态扩容也不可能达到hash值的最大值，虽然其理论最大容量为2的30次方，但限于内存的原因远远达不到这个值。因此若直接用HashMap的capacity与key的hashCode值做与运算那么实际利用的只是较低的几位(由capacity限制的)。这样一来，虽然不同的key值的hasCode值相同的几率很小，但求与运算之后的结果相同的概率会比想象中要大，发生hash碰撞的几率也会变大。因此，要想办法将key的hashCode值的高位影响向底位扩展，因此就用到了这个方法，下面看一下实际的效果：\n\n![](/images/collection/hash异或.png)\n\n这个方法也即是扰动函数，目的就是为了使得真正利用的hash值更加不确定来降低hash碰撞的几率。\n\n### 4.2.核心逻辑\n\n下面就进入到了真正的put方法，源码如下：\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    \t//tab存放当前的哈希桶，p用作临时链表节点\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \t//如果当前哈希表是空的，执行初始化操作\n        if ((tab = table) == null || (n = tab.length) == 0)\n            //初始化哈希表(resize()方法综合了初始化和扩容)\n            n = (tab = resize()).length;\n    \t//如果当前index的节点是空的，表示没有发生哈希碰撞。直接构建一个新节点Node，挂载在index处即可\n    \t//这里利用的是哈希值 & 哈希桶的长度-1，替代模运算\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {//否则 发生了哈希冲突。\n            //e临时节点\n            Node<K,V> e; K k;\n            //如果哈希值相等，key也相等，将现有节点引用赋给临时节点\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                ///将当前节点引用赋值给e\n                e = p;\n            else if (p instanceof TreeNode)//当现有节点是红黑树节点时\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                //当哈希冲突的节点是链表节点，但与链表头部节点不相等，那么需要遍历链表决定是覆盖还是添加\n                //遍历链表\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {//遍历到尾部，追加新节点到尾部\n                        p.next = newNode(hash, key, value, null);\n                        //如果追加节点后，链表数量》=8，则转化为红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    //如果找到了要覆盖的节点\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    //遍历节点后移\n                    p = e;\n                }\n            }\n            //如果e不是null，说明有需要覆盖的节点\n            if (e != null) { // existing mapping for key\n                //覆盖节点值，并返回原oldValue\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n    \t//如果执行到了这里，说明插入了一个新的节点，所以会修改modCount,并返回null\n    \t//修改modCount，即修改次数加1\n        ++modCount;\n    \t//更新size，并判断是否需要扩容(size>阈值)\n        if (++size > threshold)\n            resize();\n    \t//这是一个空实现的函数，用作LinkedHashMap重写使用\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n这里可以看得出来，当往HashMap里增添元素时，底层会根据传入的key值决定是插入新节点还是修改老节点，并且也涉及到了之前提到的**数组+单向链表+红黑树**，对每种情况都做了对应的处理。其中，当哈希表是空的以及需要扩容时都调用到了扩容方法：resize()。这是一个很重要的方法，下面看一下它的源码：\n\n```java\nfinal Node<K,V>[] resize() {\n    \t//oldTab 为当前表的哈希桶\n        Node<K,V>[] oldTab = table;\n    \t//当前哈希桶的容量 length\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    \t//当前的阈值\n        int oldThr = threshold;\n    \t//初始化新的容量和阈值为0\n        int newCap, newThr = 0;\n        if (oldCap > 0) {//当前哈希桶的容量大于0，说明是扩容不是初始化\n            //如果当前容量已经到达上限\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                //则设置阈值是2的31次方-1\n                threshold = Integer.MAX_VALUE;\n                //同时返回当前的哈希桶，不再扩容\n                return oldTab;\n            }//否则新的容量为旧的容量的两倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)//如果旧的容量大于等于默认初始容量16\n                //那么新的阈值也等于旧的阈值的两倍\n                newThr = oldThr << 1; // double threshold\n        }//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况,此时是初始化哈希桶\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            //那么新表的容量就等于旧的阈值\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            //如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况\n            //此时新表的容量为默认的容量 16\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            //新的阈值为默认容量16 * 默认加载因子0.75f = 12\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {//如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况\n            //根据新表容量 和 加载因子 求出新的阈值\n            float ft = (float)newCap * loadFactor;\n            //进行越界修复\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n    \t//更新阈值 \n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    \t\t//根据新的容量 构建新的哈希桶\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    \t//更新哈希桶引用\n        table = newTab;\n    \t//如果以前的哈希桶中有元素\n        //下面开始将当前哈希桶中的所有节点转移到新的哈希桶中\n        if (oldTab != null) {\n            //遍历老的哈希桶\n            for (int j = 0; j < oldCap; ++j) {\n                //临时节点e\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {//如果当前桶中有元素,则将链表赋值给e\n                    //将原哈希桶置空以便GC\n                    oldTab[j] = null;\n                    if (e.next == null)//如果当前链表中就一个元素\n                        //直接将这个元素放置在新的哈希桶里。\n                        //注意这里取下标是用 哈希值 与 桶的长度-1\n                        //由于桶的长度是2的n次方，这么做其实是等于一个模运算。但是效率更高\n                        newTab[e.hash & (newCap - 1)] = e;\n                    //如果发生过哈希碰撞 ,而且是节点数超过8个，转化为红黑树\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order //如果当前链表不止一个元素\n                        /*\n                        因为扩容是容量翻倍，所以原链表上的每个节点,现在可能存放在原来的下标\n                        即low位，或者扩容后的下标，即high位。high位 = low位+原哈希桶容量\n                        低位链表的头结点、尾节点\n                        */\n                        Node<K,V> loHead = null, loTail = null;\n                        //高位链表的头节点、尾节点\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;//临时节点 存放e的下一个节点\n                        do {\n                            next = e.next;\n                            /*\n                            因为老哈希桶容量与hash与运算取决于哈希桶容量(较小)，所以扩容后需要重新计\t\t\t\t\t\t\t   算数据存放的位置\n                            利用哈希值与旧的容量，可以得到哈希值取模后是大于等于oldCap还是\n                            小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位\n                            */\n                            if ((e.hash & oldCap) == 0) {//给头尾节点引用赋值\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {//高位也是相同的逻辑\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);//循环直到链表结束\n                        if (loTail != null) {//将低位链表存放在原index处\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {//将高位链表存放在新index处\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n    \t//返回新的哈希桶(已按完成初始化或者扩容数据迁移)\n        return newTab;\n    }\n```\n\n下面一张图展示了HashMap的put(K key, V value)的核心逻辑，图片参考网络(自己总结后修改重新作图):\n\n![](/images/watermark/collection/HashMap-put.png)\n\n","tags":["jdk","HashMap"],"categories":["jdk","集合"]}]